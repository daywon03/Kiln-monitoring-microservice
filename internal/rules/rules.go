package rules

import (
    "fmt"
    "log"
    "sync"
    "time"

    "github.com/daywon03/Kiln-monitoring-microservice/internal/config"
    "github.com/daywon03/Kiln-monitoring-microservice/internal/kiln"
)

// Severity levels for findings
const (
    SeverityInfo = "INFO"
    SeverityWarn = "WARN"
    SeverityCrit = "CRIT"
)

// Finding represents an alert generated by a rule
type Finding struct {
    Severity  string            `json:"severity"`
    Rule      string            `json:"rule"`
    Message   string            `json:"message"`
    Context   map[string]string `json:"context"`
    Timestamp time.Time         `json:"timestamp"`
}

// Engine manages rule evaluation and historical data
type Engine struct {
    config  *config.Config
    history *HistoryManager
    mutex   sync.RWMutex
}

// HistoryManager keeps track of historical rewards for trend analysis
type HistoryManager struct {
    rewards map[string][]RewardEntry // accountID -> list of reward entries
    mutex   sync.RWMutex
}

// RewardEntry represents a historical reward data point
type RewardEntry struct {
    Timestamp time.Time
    Reward    float64
    Uptime    float64
}

// NewEngine creates a new rules engine
func NewEngine(cfg *config.Config) *Engine {
    return &Engine{
        config: cfg,
        history: &HistoryManager{
            rewards: make(map[string][]RewardEntry),
        },
    }
}

// AddSnapshot adds a new snapshot to historical data
func (e *Engine) AddSnapshot(snapshot kiln.RewardsSnapshot) {
    e.history.mutex.Lock()
    defer e.history.mutex.Unlock()

    accountID := snapshot.AccountID
    entry := RewardEntry{
        Timestamp: snapshot.WindowEnd,
        Reward:    snapshot.TotalReward,
        Uptime:    snapshot.Uptime,
    }

    // Add new entry
    e.history.rewards[accountID] = append(e.history.rewards[accountID], entry)

    // Keep only last 7 days of data (assuming 1 snapshot per minute)
    maxEntries := 7 * 24 * 60 // 7 days * 24 hours * 60 minutes
    if len(e.history.rewards[accountID]) > maxEntries {
        e.history.rewards[accountID] = e.history.rewards[accountID][len(e.history.rewards[accountID])-maxEntries:]
    }
}

// EvaluateAll evaluates all rules against a snapshot
func (e *Engine) EvaluateAll(snapshot kiln.RewardsSnapshot) []Finding {
    var findings []Finding

    // R1: Inactivity rule
    if finding := e.evaluateInactivityRule(snapshot); finding != nil {
        findings = append(findings, *finding)
    }

    // R2: Reward drop rule
    if finding := e.evaluateRewardDropRule(snapshot); finding != nil {
        findings = append(findings, *finding)
    }

    // R3: Uptime/Status rule
    if finding := e.evaluateUptimeStatusRule(snapshot); finding != nil {
        findings = append(findings, *finding)
    }

    return findings
}

// R1: Inactivity rule - no rewards in current window
func (e *Engine) evaluateInactivityRule(snapshot kiln.RewardsSnapshot) *Finding {
    if snapshot.TotalReward <= 0 {
        return &Finding{
            Severity:  SeverityWarn,
            Rule:      "R1_INACTIVITY",
            Message:   fmt.Sprintf("No rewards detected for account %s", snapshot.AccountID),
            Context: map[string]string{
                "account_id":    snapshot.AccountID,
                "total_reward":  fmt.Sprintf("%.6f", snapshot.TotalReward),
                "window_start":  snapshot.WindowStart.Format(time.RFC3339),
                "window_end":    snapshot.WindowEnd.Format(time.RFC3339),
            },
            Timestamp: time.Now(),
        }
    }
    return nil
}

// R2: Reward drop rule - significant drop compared to 24h average
func (e *Engine) evaluateRewardDropRule(snapshot kiln.RewardsSnapshot) *Finding {
    e.history.mutex.RLock()
    defer e.history.mutex.RUnlock()

    history, exists := e.history.rewards[snapshot.AccountID]
    if !exists || len(history) < 24*60 { // Need at least 24 hours of data
        return nil
    }

    // Calculate 24h average (last 24*60 minutes)
    last24h := history[len(history)-24*60:]
    var sum24h float64
    for _, entry := range last24h {
        sum24h += entry.Reward
    }
    avg24h := sum24h / float64(len(last24h))

    // Calculate 7-day average
    var sum7d, avg7d float64
    if len(history) >= 7*24*60 {
        last7d := history[len(history)-7*24*60:]
        for _, entry := range last7d {
            sum7d += entry.Reward
        }
        avg7d = sum7d / float64(len(last7d))
    } else {
        // Use available history
        for _, entry := range history {
            sum7d += entry.Reward
        }
        avg7d = sum7d / float64(len(history))
    }

    // Check if current reward is significantly lower than average
    if avg7d > 0 {
        dropPercent := ((avg7d - snapshot.TotalReward) / avg7d) * 100
        threshold := e.config.Rules.RewardDropThresholdPct

        if dropPercent > threshold {
            severity := SeverityWarn
            if dropPercent > threshold*2 {
                severity = SeverityCrit
            }

            return &Finding{
                Severity: severity,
                Rule:     "R2_REWARD_DROP",
                Message: fmt.Sprintf("Reward drop detected: %.1f%% below 7-day average for account %s", 
                    dropPercent, snapshot.AccountID),
                Context: map[string]string{
                    "account_id":       snapshot.AccountID,
                    "current_reward":   fmt.Sprintf("%.6f", snapshot.TotalReward),
                    "avg_24h":         fmt.Sprintf("%.6f", avg24h),
                    "avg_7d":          fmt.Sprintf("%.6f", avg7d),
                    "drop_percent":    fmt.Sprintf("%.1f", dropPercent),
                    "threshold":       fmt.Sprintf("%.1f", threshold),
                },
                Timestamp: time.Now(),
            }
        }
    }

    return nil
}

// R3: Uptime/Status rule - low uptime or bad status
func (e *Engine) evaluateUptimeStatusRule(snapshot kiln.RewardsSnapshot) *Finding {
    minUptime := e.config.Rules.MinUptime

    // Check for critical statuses
    criticalStatuses := []string{"inactive", "penalized", "slashed", "exited"}
    for _, status := range criticalStatuses {
        if snapshot.Status == status {
            return &Finding{
                Severity: SeverityCrit,
                Rule:     "R3_STATUS_CRITICAL",
                Message: fmt.Sprintf("Critical validator status '%s' detected for account %s", 
                    snapshot.Status, snapshot.AccountID),
                Context: map[string]string{
                    "account_id": snapshot.AccountID,
                    "status":     snapshot.Status,
                    "uptime":     fmt.Sprintf("%.2f%%", snapshot.Uptime*100),
                },
                Timestamp: time.Now(),
            }
        }
    }

    // Check for low uptime
    if snapshot.Uptime < minUptime {
        return &Finding{
            Severity: SeverityWarn,
            Rule:     "R3_LOW_UPTIME",
            Message: fmt.Sprintf("Low uptime detected: %.2f%% (threshold: %.2f%%) for account %s", 
                snapshot.Uptime*100, minUptime*100, snapshot.AccountID),
            Context: map[string]string{
                "account_id":  snapshot.AccountID,
                "uptime":      fmt.Sprintf("%.2f%%", snapshot.Uptime*100),
                "threshold":   fmt.Sprintf("%.2f%%", minUptime*100),
                "status":      snapshot.Status,
            },
            Timestamp: time.Now(),
        }
    }

    return nil
}

// GetAccountHistory returns historical data for an account (for debugging)
func (e *Engine) GetAccountHistory(accountID string) []RewardEntry {
    e.history.mutex.RLock()
    defer e.history.mutex.RUnlock()

    if history, exists := e.history.rewards[accountID]; exists {
        // Return copy to avoid race conditions
        result := make([]RewardEntry, len(history))
        copy(result, history)
        return result
    }
    return nil
}

// LogStats logs statistics about the rules engine
func (e *Engine) LogStats() {
    e.history.mutex.RLock()
    defer e.history.mutex.RUnlock()

    for accountID, history := range e.history.rewards {
        log.Printf("Rules engine stats - Account: %s, History entries: %d", accountID, len(history))
    }
}
